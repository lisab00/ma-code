export plot_ll_grid, plot_fisher_grid, plot_ll

"""
    function plot_ll(evals_df::DataFrame, cutoff::Int64, mle::Vector, prm_keys::Vector)

Plot of log-likelihood evaluations highlighting the MLE.

# Arguments
    - `evals_df::DataFrame`: Log-likelihood evaluations generated by `gen_ll_evals`
    - `cutoff::Int64`: Minimum value threshold; entries below this value are ignored (set to NaN)
    - `mle::Vector`: Maximum likelihood estimate of the parameters (used to mark the best estimate)
    - `prm_keys::Vector`: Names of the inferred parameters
"""
function plot_ll(evals_df::DataFrame, cutoff::Int64, point::Vector, prm_keys::Vector; grid_plot::Bool=false, levels::Int64=300)

    if length(prm_keys)==2

        evals = Matrix(select(evals_df, names(evals_df, Number)))

        rx = range(0.0,2.0, length=size(evals,1))
        ry = range(0.0,2.0, length=size(evals,2))

        evals_cutoff = map(z -> z < cutoff ? NaN : z, evals)

        p = heatmap(rx, ry, evals_cutoff, alpha=0.9, xlabel=prm_keys[1], ylabel=prm_keys[2], title="", 
            #color=reverse(tum_cgrad),
            color=tum_cgrad,
            colorbar=false, xticks = [0.0, 1.0, 2.0], yticks = [1.0, 2.0],
            xtickfontsize=10, ytickfontsize=10, legendfontsize=14)
        contour!(rx, ry, evals_cutoff, linewidth=1, linecolor=:black, levels=levels, label=false)
        if grid_plot
            scatter!([point[1]],[point[2]], markershape=:x, markerstrokewidth=1, markersize=2, color="#F7811E", label="")
        else
            scatter!([point[1]],[point[2]], markershape=:x, markerstrokewidth=5, markersize=8, color="#F7811E", label="MLE")
        end
    else
        rx = 0.0:0.01:2.0
        evals = evals_df[:,1]
        evals_cutoff = map(z -> z < cutoff ? NaN : z, evals)
        p = plot(rx, evals_cutoff, linewidth=3, color="#3070B3", xlabel=prm_keys[1], ylabel="", label="", title="",
        xtickfontsize=10, ytickfontsize=10, legendfontsize=14)
        vline!([point[1]], color="#F7811E", label="MLE", linestyle=:dash, linewidth=2)
    end
    return p
end

"""
    function plot_ll_grid(point::Vector, prm_keys::Vector, noise_vals::Vector, M_vals::Vector, cutoff::Int64, path_to_read::String; a::Float64=1.3, m::Float64=0.45, n0::Float64=1.0, w0::Float64=1.0)


Create a 3×3 grid of log-likelihood heatmaps for different noise and M values.
- M decreases from left to right.
- noise increases from top to bottom.

# Arguments
    - `point`: Vector of true parameter value
    - `noise_vals`: Vector of 3 noise levels (in increasing order)
    - `M_vals`: Vector of 3 M values (in decreasing order)
    - `lower_bound`: cutoff below which ll values are truncated
    - `path_to_read`: path to folder where CSVs are stored
"""
function plot_ll_grid(point::Vector, prm_keys::Vector, noise_vals::Vector, M_vals::Vector, cutoff::Int64, path_to_read::String; a::Float64=1.3, m::Float64=0.45, n0::Float64=1.0, w0::Float64=1.0, grid_plot::Bool=false, levels=levels)

    plots_matrix = Array{Any}(undef, 3, 3)

    prms = Dict(zip(prm_keys, point))
    a_val = get(prms, :a, a)
    n0_val = get(prms, :n0, n0)
    m_val = get(prms, :m, m)
    w0_val = get(prms, :w0, w0)

    for i in 1:3  # noise increases top→bottom
        for j in 1:3  # M decreases left→right
            ll = read_ll_file(w0_val, n0_val, a_val, m_val, M_vals[j], noise_vals[i], path_to_read)
            p = plot_ll(ll, cutoff, point, prm_keys, grid_plot=grid_plot, levels=levels)
            plots_matrix[i, j] = p
        end
    end
    return plot(plots_matrix..., layout=(3,3), size=(900,900),
                      title=" ", colorbar=false)
end

"""
    function read_ll_file(w0::Float64, n0::Float64, a::Float64, m::Float64, M::Int64, noise::Float64, path_to_file::String)

Reads log-likelihood file stored in the format: "ll_w0_n0_a_m_M_noise.csv"

# Arguments 
    - `w0, n0, a, m, M, noise`: Parameter values (used to build the filename) 
    - `path_to_file`: Directory path where the file is stored 
    
# Returns
    - `DataFrame`: Contents of the CSV file 
"""
function read_ll_file(w0::Float64, n0::Float64, a::Float64, m::Float64, M::Int64, noise::Float64, path_to_file::String)
    name = "ll_$(w0)_$(n0)_$(a)_$(m)_$(M)_$(noise).csv"
    full_path = joinpath(path_to_file, name)
    df = CSV.read(full_path, DataFrame)
    return df
end

"""
    function read_fish_file(M::Int64, noise::Float64, path_to_file::String)

Reads fisher information file stored in the format: "fish_M_noise.csv"

# Arguments
    - `M, noise`: Parameter values (used to build the filename) 
    - `path_to_file`: Directory path where the file is stored 

# Returns
    - A `DataFrame` containing the Fisher information or related evaluation results
"""
function read_fish_file(M::Int64, noise::Float64, path_to_file::String)
    name = "fish_$(M)_$(noise).csv"
    full_path = joinpath(path_to_file, name)
    df = CSV.read(full_path, DataFrame)
    return df
end


# Fisher information
"""
    function plot_fisher_an0_plane(evals_df::DataFrame; logscale::Bool=true)

Plot the Fisher information surface in the (a, n0) parameter plane as a heatmap with contour lines.

# Arguments
    - `evals_df::DataFrame`: DataFrame containing Fisher information values
    - `logscale::Bool=true`: plots the logarithm of the Fisher information values (nonpositive values are set to `NaN`)
"""
function plot_fisher_an0_plane(evals_df::DataFrame; logscale::Bool=true)

    evals = Matrix(select(evals_df, names(evals_df, Number)))

    rx = range(0.0,2.0, length=size(evals,1))
    ry = range(0.0,2.0, length=size(evals,2))

    evals = map(z -> (logscale && z > 0) ? log(z) : ((logscale && z <= 0) ? NaN : z), evals)

    tum_blues = ["#D7E4F4", "#C2D7EF", "#9ABCE4", "#5E94D4", "#165DB1", "#14519A", "#114584", "#0E396E"]
    tum_cgrad = cgrad(tum_blues)

    p = heatmap(rx, ry, evals, alpha=0.9, xlabel="a", ylabel="n0", title="Fisher Information", 
        color=tum_cgrad, colorbar=false, xticks = [0.0, 1.0, 2.0], yticks = [1.0, 2.0])
    contour!(rx, ry, evals, linewidth=1, color=tum_cgrad, levels=300, label=false)
    return p
end

"""
    function plot_fisher_grid(noise_vals::Vector, M_vals::Vector, path_to_read::String; logscale::Bool=true)

Create a 3×3 grid of fisher information heatmaps for different noise and M values.
- M decreases from left to right.
- noise increases from top to bottom.

# Arguments
    - `noise_vals::Vector`: Vector of noise levels used in the simulations (increasing top -> bottom)
    - `M_vals::Vector`: Vector of sampling densities M (decreasing left -> right)
    - `path_to_read::String`: Directory containing the Fisher information CSV files
    - `logscale::Bool=true`: plots the logarithm of Fisher information values (nonpositive values set to `NaN`)
"""
function plot_fisher_grid(noise_vals::Vector, M_vals::Vector, path_to_read::String; logscale::Bool=true)

    plots_matrix = Array{Any}(undef, 3, 3)

    for i in 1:3   # noise increases top → bottom
        for j in 1:3  # M decreases left → right
            fi_df = read_fish_file(M_vals[j], noise_vals[i], path_to_read)
            p = plot_fisher_an0_plane(fi_df; logscale=logscale)
            plots_matrix[i, j] = p
        end
    end

    return plot(plots_matrix..., layout=(3,3), size=(900,900), 
                title="", colorbar=false)
end